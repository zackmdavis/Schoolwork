#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Assignment #5
\end_layout

\begin_layout Date
1 March 2025
\end_layout

\begin_layout Abstract
Homework exercises for Prof.
 Dusty Ross's 
\begin_inset Quotes eld
\end_inset

Modern Algebra I
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Z}{\mathbb{Z}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ZnZ}[1]{\Z/#1\Z}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ZnZx}[1]{\left(\Z/#1\Z\right)^{\times}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
1
\series default
.
 
\series bold
a
\series default
.
 
\emph on
Proposition
\emph default
.
 
\begin_inset Formula $\mathbb{Z}/8\Z$
\end_inset

 and 
\begin_inset Formula $(\Z/16\Z)^{\times}$
\end_inset

 are not isomorphic.
 
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
.
 Suppose they were.
 Then 
\begin_inset Formula $(\Z/16\Z)^{\times}$
\end_inset

 would have an element of order 8.
 But it doesn't.
 (
\begin_inset Formula $|1|=1$
\end_inset

 because 
\begin_inset Formula $1^{1}\cong1\mod16$
\end_inset

, 
\begin_inset Formula $|3|=4$
\end_inset

 because 
\begin_inset Formula $3^{4}\cong1\mod16$
\end_inset

, 
\begin_inset Formula $|5|=4$
\end_inset

 because 
\begin_inset Formula $5^{4}\cong1\mod16$
\end_inset

, 
\begin_inset Formula $|7|=2$
\end_inset

 because 
\begin_inset Formula $7^{2}\cong1\mod16$
\end_inset

, 
\begin_inset Formula $|9|=2$
\end_inset

 because 
\begin_inset Formula $9^{2}\cong1\mod16$
\end_inset

, 
\begin_inset Formula $|11|=4$
\end_inset

 because 
\begin_inset Formula $11^{4}\cong1\mod16$
\end_inset

, 
\begin_inset Formula $|13|=4$
\end_inset

 because 
\begin_inset Formula $13^{4}=1\mod16$
\end_inset

, 
\begin_inset Formula $|15|=2$
\end_inset

 because 
\begin_inset Formula $15^{2}\cong1\mod16$
\end_inset

.) Contradiction!
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
b
\series default
\emph on
.
 Proposition
\emph default
.
 
\begin_inset Formula $\ZnZ 6$
\end_inset

 and 
\begin_inset Formula $\ZnZx 9$
\end_inset

 are isomorphic.
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
.
 Consider 
\begin_inset Formula $(2\ 4\ 8\ 7\ 5\ 1)\in S_{6}$
\end_inset

.
 As a 6-cycle, 
\begin_inset Formula $(2\ 4\ 8\ 7\ 5\ 1)$
\end_inset

 generates a cyclic group of order 6, so is isomorphic to 
\begin_inset Formula $\ZnZ 6$
\end_inset

.
 (There is only one cyclic group of a given order up to isomorphism.) But
 the set-elements in the cycle also represent iterated multiplication by
 2 mod 9: 
\begin_inset Formula $2\cdot2\text{\ensuremath{\cong}}4\mod9$
\end_inset

, 
\begin_inset Formula $4\cdot2\text{\ensuremath{\cong}}8\mod9$
\end_inset

, 
\begin_inset Formula $8\cdot2\text{\ensuremath{\cong}}7\mod9$
\end_inset

, 
\emph on
&c
\emph default
., so the cycle is ismorphic to 
\begin_inset Formula $\ZnZx 9$
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
2
\series default
.
 
\series bold
a
\series default
.
 
\emph on
Proposition
\emph default
.
 
\begin_inset Formula $\varphi(x)=x^{3}$
\end_inset

 is an automorphism on 
\begin_inset Formula $\ZnZx{16}$
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
.
 (Bijection.) We use the Python code
\end_layout

\begin_layout LyX-Code
from math import gcd
\end_layout

\begin_deeper
\begin_layout LyX-Code
for i in range(1, 17):
\end_layout

\begin_deeper
\begin_layout LyX-Code
if gcd(i, 16) == 1:
\end_layout

\begin_deeper
\begin_layout LyX-Code
print(i, i**3 % 16) 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
to compute the values of 
\begin_inset Formula $\varphi$
\end_inset

.
 It prints
\end_layout

\begin_layout LyX-Code
1 1
\end_layout

\begin_layout LyX-Code
3 11
\end_layout

\begin_layout LyX-Code
5 13
\end_layout

\begin_layout LyX-Code
7 7
\end_layout

\begin_layout LyX-Code
9 9
\end_layout

\begin_layout LyX-Code
11 3
\end_layout

\begin_layout LyX-Code
13 5
\end_layout

\begin_layout LyX-Code
15 15 
\end_layout

\begin_layout Standard
We observe that every number only appears once in the right column (injectivity,
 no comdomain element mapped to more than once), and that every number in
 the right column appears in the left column (surjectivity, every codomain
 element is mapped to).
\end_layout

\begin_layout Standard
(Homomorphism.) 
\begin_inset Formula $\varphi(x)\varphi(y)=x^{3}y^{3}$
\end_inset

, and 
\begin_inset Formula $\varphi(xy)=(xy)^{3}$
\end_inset

, but in an abelian group like 
\begin_inset Formula $\ZnZx{16}$
\end_inset

, we can commute elements, so 
\begin_inset Formula $(xy)^{3}=xyxyxy=xxxyyy=x^{3}y^{3}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
b
\series default
.
 
\emph on
Proposition
\emph default
.
 
\begin_inset Formula $\varphi(x)=x^{2}$
\end_inset

 is not an automorphism of 
\begin_inset Formula $\ZnZx{16}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
.
 
\begin_inset Formula $3^{2}\mod16\cong9$
\end_inset

 and 
\begin_inset Formula $5^{2}\mod16\cong9$
\end_inset

, so 
\begin_inset Formula $\varphi$
\end_inset

 is not injective.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
3
\series default
.
 
\emph on
Proposition
\emph default
.
 
\begin_inset Formula $\varphi(n)=\left[\begin{array}{cc}
1 & n\\
0 & 1
\end{array}\right]$
\end_inset

 is an isomorphism between 
\begin_inset Formula $\Z$
\end_inset

 and 
\begin_inset Formula $\left\{ \left[\begin{array}{cc}
1 & n\\
0 & 1
\end{array}\right]:n\in\Z\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
.
 (Injectivity.) Suppose 
\begin_inset Formula $\varphi(n)=\varphi(m)$
\end_inset

.
 Then 
\begin_inset Formula $\left[\begin{array}{cc}
1 & n\\
0 & 1
\end{array}\right]=\left[\begin{array}{cc}
1 & m\\
0 & 1
\end{array}\right]$
\end_inset

.
 So 
\begin_inset Formula $n=m$
\end_inset

.
\end_layout

\begin_layout Standard
(Surjectivity.) Given a matrix of the form 
\begin_inset Formula $\left[\begin{array}{cc}
1 & n\\
0 & 1
\end{array}\right]$
\end_inset

, we can find a 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $\varphi(k)=\left[\begin{array}{cc}
1 & n\\
0 & 1
\end{array}\right]$
\end_inset

, namely 
\begin_inset Formula $k:=n$
\end_inset

.
\end_layout

\begin_layout Standard
(Homomorphism.) 
\begin_inset Formula $\varphi(n)\varphi(m)=\left[\begin{array}{cc}
1 & n\\
0 & 1
\end{array}\right]\left[\begin{array}{cc}
1 & m\\
0 & 1
\end{array}\right]=\left[\begin{array}{cc}
1\cdot1+n\cdot0 & 1\cdot m+n\cdot1\\
0\cdot1+1\cdot0 & 0\cdot m+1\cdot1
\end{array}\right]=\left[\begin{array}{cc}
1 & m+n\\
0 & 1
\end{array}\right]=\varphi(mn)$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
4
\series default
.
 
\emph on
Proposition
\emph default
.
 An automorphism 
\begin_inset Formula $\varphi$
\end_inset

 of 
\begin_inset Formula $D_{2n}$
\end_inset

 maps every rotation to a rotation.
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
.
 Isomorphisms preserve the order of elements: 
\begin_inset Formula $|r|=n$
\end_inset

, so 
\begin_inset Formula $|\varphi(r)|=n$
\end_inset

.
 An element of order 
\begin_inset Formula $n$
\end_inset

 in 
\begin_inset Formula $D_{2n}$
\end_inset

 must be a rotation, so 
\begin_inset Formula $\varphi(r)$
\end_inset

 is a rotation.
 But then every other rotation 
\begin_inset Formula $\varphi(r^{k})$
\end_inset

 for 
\begin_inset Formula $k\in\{2...n-1\}$
\end_inset

 gets mapped to 
\begin_inset Formula $\varphi(r)^{k}$
\end_inset

, which, as the power of a rotation, is also a rotation.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
5
\series default
.
 We want to compute the six left cosets of 
\begin_inset Formula $H:=\{(1),(12)(34),(13)(24),(14)(23)\}$
\end_inset

 in 
\begin_inset Formula $S_{4}$
\end_inset

.
 Doing this manually would be an affront to human dignity.
 Let's write a Python program to do it.
\end_layout

\begin_layout LyX-Code
from itertools import permutations
\end_layout

\begin_layout LyX-Code
from collections import defaultdict
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Permutation:
\end_layout

\begin_layout LyX-Code
    def __init__(self, data):
\end_layout

\begin_layout LyX-Code
        self.data = data
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    def __hash__(self):
\end_layout

\begin_layout LyX-Code
        return hash(tuple(self.data))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    def cycles(self):
\end_layout

\begin_layout LyX-Code
        placed = set()
\end_layout

\begin_layout LyX-Code
        cycles = []
\end_layout

\begin_layout LyX-Code
        while len(placed) < len(self.data):
\end_layout

\begin_layout LyX-Code
            smallest_unplaced = sorted(set(self.data) - placed)[0]
\end_layout

\begin_layout LyX-Code
            cursor = smallest_unplaced
\end_layout

\begin_layout LyX-Code
            current_cycle = []
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
            while not current_cycle or cursor != current_cycle[0]:
\end_layout

\begin_layout LyX-Code
                current_cycle.append(cursor)
\end_layout

\begin_layout LyX-Code
                placed.add(cursor)
\end_layout

\begin_layout LyX-Code
                cursor = self.data[cursor-1]
\end_layout

\begin_layout LyX-Code
            else:
\end_layout

\begin_layout LyX-Code
                cycles.append(current_cycle)
\end_layout

\begin_layout LyX-Code
                smallest_unplaced = sorted(set(self.data) - placed)
\end_layout

\begin_layout LyX-Code
                cursor = smallest_unplaced
\end_layout

\begin_layout LyX-Code
                current_cycle = []
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
        return cycles
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    def __repr__(self):
\end_layout

\begin_layout LyX-Code
        cycles = self.cycles()
\end_layout

\begin_layout LyX-Code
        if all(len(cycle) == 1 for cycle in cycles):
\end_layout

\begin_layout LyX-Code
            return "1"
\end_layout

\begin_layout LyX-Code
        def print_cycle(cycle):
\end_layout

\begin_layout LyX-Code
            return "(" + " ".join(str(element) for element in cycle) + ")"
\end_layout

\begin_layout LyX-Code
        return "".join(print_cycle(cycle) for cycle in cycles if len(cycle)
 != 1)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    def __eq__(self, other):
\end_layout

\begin_layout LyX-Code
        return self.data == other.data
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    def __lt__(self, other):
\end_layout

\begin_layout LyX-Code
        return self.data < other.data
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    def __mul__(self, other):
\end_layout

\begin_layout LyX-Code
        return Permutation([other.data[a-1] for a in self.data])
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
if __name__ == "__main__":
\end_layout

\begin_layout LyX-Code
        h = [
\end_layout

\begin_layout LyX-Code
        Permutation([1, 2, 3, 4]),
\end_layout

\begin_layout LyX-Code
        Permutation([2, 1, 4, 3]),
\end_layout

\begin_layout LyX-Code
        Permutation([3, 4, 1, 2]),
\end_layout

\begin_layout LyX-Code
        Permutation([4, 3, 2, 1]),
\end_layout

\begin_layout LyX-Code
    ] 
\end_layout

\begin_layout LyX-Code
    s_4 = [Permutation(p) for p in permutations((1, 2, 3, 4))]
\end_layout

\begin_layout LyX-Code
    coset_map = defaultdict(list)
\end_layout

\begin_layout LyX-Code
    for element in s_4:
\end_layout

\begin_layout LyX-Code
        coset = tuple(sorted(element * h_j for h_j in h))
\end_layout

\begin_layout LyX-Code
        coset_map[coset].append(element)
\end_layout

\begin_layout LyX-Code
    for coset, elements in coset_map.items():
\end_layout

\begin_layout LyX-Code
      print(
\end_layout

\begin_layout LyX-Code
          " = ".join([
\end_layout

\begin_layout LyX-Code
              "{" + ', '.join(repr(coset_member) for coset_member in coset)
 + "}",
\end_layout

\begin_layout LyX-Code
              *[repr(element)+"H" for element in elements]
\end_layout

\begin_layout LyX-Code
          ])
\end_layout

\begin_layout LyX-Code
      )
\end_layout

\begin_layout Standard
Running the program yields:
\end_layout

\begin_layout LyX-Code
zmd@system76-pc:~/Documents/School/Algebra$ python3 symmetric_cosets.py
\end_layout

\begin_layout LyX-Code
{1, (1 2)(3 4), (1 3)(2 4), (1 4)(2 3)} = 1H = (1 2)(3 4)H = (1 3)(2 4)H
 = (1 4)(2 3)H 
\end_layout

\begin_layout LyX-Code
{(3 4), (1 2), (1 3 2 4), (1 4 2 3)} = (3 4)H = (1 2)H = (1 3 2 4)H = (1
 4 2 3)H 
\end_layout

\begin_layout LyX-Code
{(2 3), (1 2 4 3), (1 3 4 2), (1 4)} = (2 3)H = (1 2 4 3)H = (1 3 4 2)H
 = (1 4)H
\end_layout

\begin_layout LyX-Code
{(2 3 4), (1 2 4), (1 3 2), (1 4 3)} = (2 3 4)H = (1 2 4)H = (1 3 2)H =
 (1 4 3)H
\end_layout

\begin_layout LyX-Code
{(2 4 3), (1 2 3), (1 3 4), (1 4 2)} = (2 4 3)H = (1 2 3)H = (1 3 4)H =
 (1 4 2)H
\end_layout

\begin_layout LyX-Code
{(2 4), (1 2 3 4), (1 3), (1 4 3 2)} = (2 4)H = (1 2 3 4)H = (1 3)H = (1
 4 3 2)H
\end_layout

\end_body
\end_document
